# ミエルボード for 現場 / ミエルボード - Cursor AI ルール

このプロジェクトは AI駆動開発を前提としています。
以下のルールを厳守し、品質・セキュリティ・保守性を担保してください。

---

## 📍 現在のPhase: Phase 0

### Phase 0 運用ルール
- main直接push: ✅ 許可
- PR/レビュー: 任意
- スピード優先、MVP検証に集中

### ⚠️ Phase 1 移行時の作業
Phase 1 開始時は以下を実行:
1. GitHub main保護を厳格化
2. この「現在のPhase」を更新
3. `>> write PHASE1_MIGRATION` で移行手順を確認

---

## 🚨 禁止操作（CI違反で自動拒否）

以下の操作は **CIで自動検出** され、PRがブロックされます。
ガードレールより厳格な「絶対禁止」です。

### 禁止1: 生SQL DDL/DML

```typescript
// ❌ 禁止（CIで検出 → PR拒否）
await prisma.$queryRaw`CREATE TABLE ...`
await prisma.$executeRaw`ALTER TABLE ...`
await prisma.$executeRaw`INSERT INTO ...`

// ✅ 許可
await prisma.user.create({ data: { ... } })
await prisma.schedule.findMany({ where: { ... } })
```

**検出パターン**: `$queryRaw` / `$executeRaw`  
**例外**: なし

---

### 禁止2: マイグレーションファイルの改ざん

```bash
# ❌ 禁止（CIで検出 → PR拒否）
prisma/migrations/20240101_init/migration.sql を編集

# ✅ 許可
prisma migrate dev --name add_new_table  # 新規マイグレーション作成
```

**検出**: 既存 `migration.sql` ファイルの変更  
**理由**: マイグレーション履歴の改ざんはDB不整合の原因

---

### 禁止3: スキーマ変更時のマイグレーション漏れ

```bash
# ❌ 禁止（CI警告）
schema.prisma を変更して、migration.sql を作成しない

# ✅ 必須手順
1. prisma/schema.prisma を編集
2. npx prisma migrate dev --name <変更内容>
3. 生成されたマイグレーションをコミット
```

**検出**: `schema.prisma` 変更あり + `migration.sql` 追加なし

---

## 🛡️ AI駆動開発ガードレール

### 1. データベース整合性（最重要）

**原則**: PrismaスキーマとDBは常に一致させる

#### ❌ 絶対禁止
- **生SQLでのDDL操作**
  - CREATE TABLE / ALTER TABLE / DROP TABLE
  - CREATE INDEX / DROP INDEX
  - その他スキーマ変更SQL
- **Prismaを経由しないDB変更**
  - psql / pgAdmin 等での直接DDL実行
  - マイグレーションファイルの手動編集・削除
- **prisma.$queryRaw / $executeRaw でのDDL/DML**
  - DDL（スキーマ変更）: 完全禁止
  - DML（INSERT/UPDATE/DELETE）: 禁止（Prisma ORM使用）
  - SELECT: 例外的に許可（Prismaで表現できない複雑なクエリのみ）

#### ✅ 必須手順（スキーマ変更時）
1. `prisma/schema.prisma` を編集
2. `npx prisma migrate dev --name <変更内容>` を実行
3. 生成されたマイグレーションファイルをコミット
4. Prisma Clientを再生成（`npx prisma generate`）
5. `prisma/seed.ts` を必要に応じて更新

#### ✅ 許可される操作
- Prisma ORMを経由したCRUD操作
- `prisma migrate dev` によるスキーマ変更
- `prisma db seed` によるシードデータ投入
- `prisma migrate status` による状態確認

---

### 2. マルチテナント整合性

#### ❌ 絶対禁止
- organizationId なしのクエリ
- organizationId ?? 'default' のようなフォールバック
- 他テナントのデータへのアクセス

#### ✅ 必須
- すべてのAPIで `requireAuth()` を使用
- すべてのクエリで `organizationId` でフィルタ

---

### 3. コード整合性

#### ❌ 禁止
- 型定義を変更せずに実装だけ変更
- SSOTを更新せずに仕様変更
- APIレスポンス形式を変更してフロントエンド未更新

#### ✅ 必須
- 変更は「定義 → 実装」の順
- 型変更時は影響範囲を確認
- SSOT変更時は `>> rfv` で検証

---

### 4. プロジェクト管理整合性

#### ❌ 禁止
- 実装完了後のPlane更新忘れ
- 複数Issueを1コミットに混在
- コミットせずに長時間作業

#### ✅ 必須
- 1 Issue = 1 Branch = 1 PR（理想）
- 実装完了時は必ずPlane更新
- 小さく頻繁にコミット

---

### 5. 環境整合性

#### ❌ 禁止
- .envを直接編集して共有しない変更
- ローカル依存パッケージの追加（package.json未更新）
- 環境固有の設定をハードコード

#### ✅ 必須
- 環境変更はREADME/ドキュメント更新
- 新規環境変数は `.env.example` にも追加
- `npm ci` で依存関係を再現可能に

---

### 6. AI行動規範

#### ❌ 禁止
- ファイル存在を確認せずに編集
- 破壊的操作を承認なしに実行
- 推測で動作（不明点は確認）

#### ✅ 必須
- 編集前に `read_file` / `ls` で確認
- 削除・上書きは事前に報告
- 不明点は推測せず質問

---

## 🚫 従来の絶対禁止事項（継続）

### マルチテナント
- ❌ organizationId なしのクエリ
- ❌ organizationId ?? 'default' のようなフォールバック
- ✅ すべてのAPIで requireAuth() を使用し、organizationId でフィルタ

### SQL・ORM
- ❌ 生SQLクエリ（prisma.$queryRaw 等でのDDL/DML禁止）
- ✅ Prisma ORMのみ使用

詳細は docs/QUALITY_MANAGEMENT_OVERVIEW.md を参照してください。

---

## 🏷️ タグ方式コマンド（ワークフロー起動）

このプロジェクトでは、**会話ベースの開発フローに「軽量コマンド」を埋め込む**ことで、一貫したインターフェースで作業を進めます。

### 基本コンセプト

- **先頭に `>>` を付けたタグコマンド**で、AIの挙動モード（仕様作成／実装／修正など）を明示
- タグなし = 通常の設計ディスカッション・質問
- タグあり = 機械的ワークフローを起動

---

### `>> write` - SSOT新規作成

**用途**: 新しいSSOTドキュメントを作成

**入力例**:
```
>> write SSOT_GENBA_STOCK
```

**振る舞い**:
1. 既存SSOT（`docs/SSOT_GENBA_WEEK.md`）と実装コードを調査
2. SSOTテンプレートに沿って新規ドキュメントを作成
3. 品質チェックリスト（必要なら参照）でセルフレビュー
4. 作成後、`docs/INDEX_WEAK_CURRENT.md` に追記

**制約**:
- マルチテナント原則を前提
- 既存SSOTとの整合性を必ず確認

---

### `>> impl` - SSOT実装

**用途**: SSOTに基づいて実装を行う

**入力例**:
```
>> impl SSOT_GENBA_WEEK
```

**振る舞い**:
1. 該当SSOTを読み込み、要件IDを抽出
2. 既存実装の有無をスキャン（`server/api/`, `components/` など）
3. 実装プラン（Item/Step）を提示 → **ユーザー承認必須**
4. 承認後、SSOT準拠の実装を行う
5. テスト作成・実行（`docs/TEST_STRATEGY.md` 参照）
   - `npm run typecheck` **必須**
   - `npm run test` **必須**（Phase 0: 認証・マルチテナント境界のユニットテスト）
6. Evidence提出
   - テスト結果の出力（またはスクリーンショット）を報告に含める
7. Plane Issue を更新（可能なら）

**制約**:
- 実装前に必ずSSOTを**最後まで読む**
- `requireAuth()` / `organizationId` フィルタ必須
- 生SQL禁止
- 実装完了までユーザー承認なしに進めない

---

### `>> fix` - バグ修正

**用途**: SSOT準拠の観点からバグを修正

**入力例**:
```
>> fix SSOT_GENBA_WEEK スケジュール削除エラー
```

**振る舞い**:
1. 該当SSOTと現行実装を突き合わせ
2. 「どこがSSOTと矛盾しているか」を整理
3. 原因調査（15分以内に特定できない場合は停止して報告）
4. 修正方針を提案 → **ユーザー承認必須**
5. 承認後、修正実施
6. テスト実行・Evidence提出

**制約**:
- Implementation Halt Protocol を前提
- 「闇雲に直す」のを防ぐため、必ず原因特定してから修正

---

### `>> rfv` - SSOT実装検証（Review）

**用途**: SSOTと実装のカバレッジ・ギャップを可視化

**入力例**:
```
>> rfv SSOT_GENBA_WEEK
```

**振る舞い**:
1. SSOTに定義された要件IDとコード・挙動を突き合わせ
2. **カバレッジ**（どこまで実装済み）と**ギャップ**（どこが未実装）を可視化
3. レポートを生成（`reports/` または チャット内）

**重要**:
- このタグは「仕様 vs 実装の差分」確認用
- **進捗の正はあくまで Plane**（このタグの結果を進捗根拠にしない）

---

### `>> next` - 次タスク選定

**用途**: Planeから次に着手すべきIssueを選定

**入力例**:
```
>> next
```

**振る舞い**:
1. `scripts/plane-lib/list-issues.cjs` 実行（Plane API経由）
2. 依存関係・Phase・優先度を分析
3. 「今着手すべき Issue」を提案
4. **ユーザー承認後**、Issueを "In Progress" に更新

**制約**:
- AIが勝手にタスクを選ばない
- Planeの状態に沿ったロードマップ運用を強制

---

### `>> prmt` - プロンプト生成

**用途**: 実装AI向けの詳細プロンプトを生成

**入力例**:
```
>> prmt WBS-12
```

**振る舞い**:
1. Plane から対象 Issue の詳細を取得
2. 関連するSSOT / ガードレール / 標準テンプレートを読み込み
3. 実装AI用の詳細プロンプト（Item/Step構造・Evidence要件・停止トリガーなどを含む）を**チャット内にだけ**生成
4. **プロンプトはファイル保存せず**、コピペ運用

**制約**:
- プロンプトを `docs/` に保存しない（Docs化禁止）
- 一時的な作業指示であり、SSOTとは別レイヤー

---

## 🔄 タグ方式の運用ルール

### 1. タグは「フェーズ切り替えスイッチ」

- **仕様作成フェーズ** → `>> write`
- **仕様実装フェーズ** → `>> impl`
- **バグ修正フェーズ** → `>> fix`
- **検証フェーズ** → `>> rfv`
- **タスク選定フェーズ** → `>> next`
- **プロンプト生成フェーズ** → `>> prmt`

### 2. タグごとに「標準フロー」が決まっている

- `>> write`: 調査 → SSOTドラフト → 品質チェック
- `>> impl`: SSOT読了 → 既存実装スキャン → 実装プラン → 承認 → 実装 → テスト
- `>> fix`: SSOT照合 → 原因調査 → 修正方針 → 承認 → 修正 → テスト
- `>> rfv`: SSOT読了 → コードスキャン → カバレッジレポート
- `>> next`: Plane問い合わせ → 候補提示 → ユーザー合意 → Issue更新
- `>> prmt`: Plane取得 → SSOT読了 → プロンプト生成

### 3. 進捗の正は Plane

- `>> next` / `>> prmt` / `>> impl` など、進捗やスコープ判断が必要なタグは、必ず Plane API 経由で Issue 状態を取得
- **SSOT内の「実装状況」テキストは進捗根拠に使わない**

### 4. 通常会話との分離

- **タグなし**: 自由なディスカッション、設計相談、質問
- **`>>` 付き**: 機械的ワークフローを起動する合図

---

### 5. 自然言語からタグへの変換

ユーザーが以下のように言った場合、**対象SSOTを自動特定してタグを返す**：

| ユーザー発言 | AI応答 |
|-------------|--------|
| 「監査して」「厳しくチェックして」 | 直近で実装したSSOTを特定し `>> rfv SSOT_XXX` を提示 |
| 「次のタスクは？」 | `>> next` を提示 |
| 「バグを直して」 | 関連するSSOTを特定し `>> fix SSOT_XXX <問題概要>` を提示 |

**対象SSOT特定の優先順位**:
1. 直前の会話で言及されたSSSOT
2. 直近で `>> impl` されたSSSOT（INDEX_WEAK_CURRENT.md の更新日時）
3. 不明な場合は候補を列挙してユーザーに確認

---

詳細は `docs/TAG_COMMANDS.md` を参照してください。
