# 25_VERIFICATION_LOOPS.md - 検証ループ

> 実装の品質を継続的に検証し、問題を早期発見する仕組み

---

## 基本原則

```
「作って終わり」ではなく「作って検証して初めて完了」。

従来:
  実装 → テスト → レビュー → マージ
  問題発見が遅い。手戻りが大きい。

検証ループ:
  実装 → checkpoint → 検証 → 修正 → checkpoint → 検証 → ...
  小さなサイクルで品質を積み上げる。
```

---

## 2種類の検証

### Checkpoint Eval（特定時点での品質検証）

```
/checkpoint コマンドで明示的に検証を実行する。

いつ使うか:
  - 機能の実装が一段落したとき
  - PR作成前の最終確認
  - リファクタリング後
  - バグ修正後

実行フロー:
  /checkpoint
    │
    ├── 1. 現在の状態をスナップショット
    │   → 変更ファイル一覧
    │   → テスト結果
    │   → lint結果
    │
    ├── 2. 評価を実行
    │   → SSOTとの整合性チェック
    │   → コード品質チェック
    │   → テストカバレッジチェック
    │
    ├── 3. 結果をレポート
    │   → スコアカード表示
    │   → 問題点のリスト
    │   → 推奨アクション
    │
    └── 4. 状態を保存
        → .claude/checkpoints/{timestamp}.json
```

### Continuous Eval（継続的な品質監視）

```
バックグラウンドで常時品質を監視する。

いつ使うか:
  - 長時間の開発セッション
  - 複数機能の連続実装
  - 大規模リファクタリング

監視項目:
  - ファイル変更時の自動lint
  - テスト実行（変更に関連するテストのみ）
  - SSOT参照の整合性
  - import/export の一貫性
  - 型安全性の維持

実行フロー:
  /verify --continuous
    │
    ├── ファイル保存を検知
    │   → 変更ファイルに関連するチェックを実行
    │   → 問題があれば即通知
    │
    └── 一定間隔で全体チェック
        → 依存関係の整合性
        → 未使用コードの検出
        → テスト結果の変化
```

---

## /checkpoint コマンド

### 基本構文

```
/checkpoint [options]

オプション:
  --name <name>     チェックポイントに名前を付ける
  --compare <id>    前のチェックポイントと比較
  --restore <id>    指定したチェックポイントに戻る
```

### 実行時の出力

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 Checkpoint: CP-003 "AUTH-001 API完了"
   Timestamp: 2025-01-15 10:30:00

📊 評価結果:

  SSOT整合性:     ██████████ 100%  ✅
  コード品質:     ████████░░  80%  ⚠️
  テストカバレッジ: ███████░░░  70%  ⚠️
  型安全性:       ██████████ 100%  ✅
  lint:           █████████░  90%  ✅

  総合スコア: 88/100

📝 問題点:
  1. [コード品質] src/api/auth.ts:45 - 関数が30行超過（推奨: 20行以下）
  2. [テスト] loginHandler のエラーケースが未テスト
  3. [コード品質] src/api/auth.ts:72 - ネストが4段階（推奨: 3段階以下）

🔧 推奨アクション:
  1. loginHandler を分割（validateInput + processLogin）
  2. エラーケーステストを追加（401, 422, 429）
  3. early return パターンでネストを削減

前回との比較（CP-002）:
  SSOT整合性:     100% → 100%  (=)
  コード品質:      60% →  80%  (+20) ⬆️
  テストカバレッジ:  50% →  70%  (+20) ⬆️
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### チェックポイントの保存形式

```json
{
  "id": "CP-003",
  "name": "AUTH-001 API完了",
  "timestamp": "2025-01-15T10:30:00Z",
  "task": "AUTH-001",
  "files_changed": [
    "src/api/auth.ts",
    "src/middleware/rateLimit.ts",
    "tests/api/auth.test.ts"
  ],
  "scores": {
    "ssot_alignment": 100,
    "code_quality": 80,
    "test_coverage": 70,
    "type_safety": 100,
    "lint": 90,
    "total": 88
  },
  "issues": [
    {
      "category": "code_quality",
      "file": "src/api/auth.ts",
      "line": 45,
      "message": "関数が30行超過",
      "severity": "warning"
    }
  ],
  "recommendations": [
    "loginHandler を分割",
    "エラーケーステストを追加",
    "early return パターンでネストを削減"
  ]
}
```

---

## /verify コマンド

### 基本構文

```
/verify [target] [options]

target:
  ssot          SSOTとの整合性検証
  code          コード品質検証
  tests         テスト実行 + カバレッジ
  types         型安全性検証
  all           上記全て（デフォルト）

オプション:
  --continuous    継続的監視モード
  --fix           自動修正可能な問題を修正
  --strict        厳格モード（警告もエラー扱い）
```

### 検証項目の詳細

```
1. SSOT整合性検証
────────────────────────────────
  チェック内容:
  - API実装がSSOT-3のエンドポイント定義と一致するか
  - DB実装がSSOT-4のスキーマ定義と一致するか
  - UI実装がSSOT-2の画面定義と一致するか
  - ビジネスルールがSSOTの§7と一致するか

  判定:
  - 完全一致: ✅ PASS
  - 差異あり（SSOT側が正）: ⚠️ コード修正が必要
  - 差異あり（コード側が正）: ⚠️ SSOT更新が必要
  - 未定義: ❌ SSOT追記が必要

2. コード品質検証
────────────────────────────────
  チェック内容:
  - 関数の長さ（20行以下推奨）
  - ネストの深さ（3段階以下推奨）
  - 重複コードの検出
  - 未使用変数/import
  - console.log の残存
  - any 型の使用

  判定:
  - スコア 90+ : ✅ PASS
  - スコア 70-89: ⚠️ 改善推奨
  - スコア 69以下: ❌ FAIL

3. テスト検証
────────────────────────────────
  チェック内容:
  - テストの存在確認（実装ファイルに対応するテストがあるか）
  - テスト実行（全テストがパスするか）
  - カバレッジ（80%以上推奨）
  - エッジケースのカバー

  判定:
  - 全テストパス + カバレッジ80%+: ✅ PASS
  - テストパス + カバレッジ80%未満: ⚠️ テスト追加推奨
  - テスト失敗あり: ❌ FAIL

4. 型安全性検証
────────────────────────────────
  チェック内容:
  - TypeScriptの型エラー
  - any 型の使用箇所
  - 型アサーション（as）の使用箇所
  - 型ガードの適切な使用

  判定:
  - エラーなし + any なし: ✅ PASS
  - エラーなし + any あり: ⚠️ 型の厳格化推奨
  - 型エラーあり: ❌ FAIL
```

---

## 評価指標

### pass@k metrics

```
pass@k: k回の試行のうち、少なくとも1回正しい結果を出す確率。

使用場面:
  - コード生成の品質評価
  - テスト生成の網羅性評価
  - リファクタリングの正確性評価

計算:
  pass@1: 1回の試行で正解する確率
  pass@3: 3回の試行で少なくとも1回正解する確率
  pass@5: 5回の試行で少なくとも1回正解する確率

目標値:
  pass@1 ≥ 80%  （1回で正しい実装ができる）
  pass@3 ≥ 95%  （3回以内に正しい実装に到達）

追跡方法:
  各タスクの完了時に記録:
  - 初回で正しかった → pass@1 成功
  - 修正が必要だった → pass@1 失敗、修正回数を記録
  - {修正回数}回で完了 → pass@{修正回数} で記録
```

### Grader Types（評価者タイプ）

```
3種類の評価者を使い分ける:

1. Auto Grader（自動評価）
────────────────────────────────
  判定者: ツール（linter, テスト, 型チェッカー）
  対象:
  - lint エラー → 自動判定
  - テスト結果 → 自動判定
  - 型エラー → 自動判定
  - カバレッジ → 自動計算

  メリット: 即座に結果が出る。客観的。
  デメリット: 意味的な品質は評価できない。

2. AI Grader（AI評価）
────────────────────────────────
  判定者: AI（Adversarial Review の Role B）
  対象:
  - コードの可読性
  - 設計の妥当性
  - SSOTとの意味的整合性
  - エッジケースの網羅性

  メリット: 意味的な評価が可能。
  デメリット: 判定にばらつきがある。

3. Human Grader（人間評価）
────────────────────────────────
  判定者: ユーザー
  対象:
  - ビジネス要件の充足
  - UX/UIの妥当性
  - 最終的な品質判断

  メリット: 最終的な正確性。
  デメリット: 時間がかかる。

組み合わせ（ハイブリッド評価）:
  Auto Grader で基本的な品質を担保
    ↓
  AI Grader で意味的な品質を評価
    ↓
  Human Grader で最終判断

  フロー:
  /verify → Auto Grader → PASS? → AI Grader → PASS? → ユーザー確認
                    ↓ FAIL            ↓ FAIL
                  修正              修正
```

---

## 検証ループのフロー

### 単一タスクの検証ループ

```
タスク開始
  │
  ▼
実装（Phase 1: 基本実装）
  │
  ▼
/checkpoint "基本実装完了"
  │
  ├── Auto Grader: lint + テスト + 型
  │   └── FAIL → 修正 → 再checkpoint
  │
  ├── PASS
  │
  ▼
実装（Phase 2: エッジケース対応）
  │
  ▼
/checkpoint "エッジケース完了"
  │
  ├── Auto Grader: lint + テスト + 型
  │   └── FAIL → 修正 → 再checkpoint
  │
  ├── PASS
  │
  ▼
/verify all
  │
  ├── AI Grader: Adversarial Review
  │   └── 指摘あり → 修正 → 再verify（最大3回）
  │
  ├── PASS
  │
  ▼
ユーザー確認
  │
  ├── 修正要求 → 修正 → /checkpoint → 再verify
  │
  └── 承認 → タスク完了 ✅
```

### 連続タスクの検証ループ

```
タスクA実装
  │
  ▼
/checkpoint "タスクA完了"  ← Checkpoint Eval
  │
  ▼
タスクB実装
  │
  ├── /verify --continuous  ← Continuous Eval（バックグラウンド）
  │   → タスクAの変更が壊れていないか監視
  │
  ▼
/checkpoint "タスクB完了"  ← Checkpoint Eval
  │
  ▼
/verify all               ← 全体検証
  │
  ▼
ユーザー確認
```

---

## チェックポイントの管理

### 保存先

```
.claude/checkpoints/
├── CP-001_2025-01-15T09-00_init.json
├── CP-002_2025-01-15T09-30_auth-api.json
├── CP-003_2025-01-15T10-30_auth-complete.json
└── _index.json                ← チェックポイント一覧
```

### _index.json

```json
{
  "checkpoints": [
    {
      "id": "CP-003",
      "name": "AUTH-001 API完了",
      "timestamp": "2025-01-15T10:30:00Z",
      "task": "AUTH-001",
      "total_score": 88
    },
    {
      "id": "CP-002",
      "name": "AUTH-001 基本実装",
      "timestamp": "2025-01-15T09:30:00Z",
      "task": "AUTH-001",
      "total_score": 65
    }
  ],
  "stats": {
    "total_checkpoints": 3,
    "average_score": 78,
    "trend": "improving"
  }
}
```

### チェックポイント間の比較

```
/checkpoint --compare CP-002

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 CP-002 → CP-003 の変化

  SSOT整合性:     100% → 100%  (=)
  コード品質:      60% →  80%  (+20) ⬆️
  テストカバレッジ:  50% →  70%  (+20) ⬆️
  型安全性:        90% → 100%  (+10) ⬆️
  lint:            70% →  90%  (+20) ⬆️

  総合: 65 → 88 (+23) ⬆️

  新しいファイル: +2
  変更ファイル: 3
  解決した問題: 5
  新しい問題: 2
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## CLAUDE.md への組み込み

```markdown
## 検証ループ

実装完了時には必ず /checkpoint を実行し品質を検証すること。
PR作成前には /verify all を実行すること。
詳細: docs/standards/25_VERIFICATION_LOOPS.md
```

---

## 既存の品質ゲートとの関係

```
検証ループ（本ドキュメント）:
  → 開発中の継続的な品質チェック
  → /checkpoint と /verify による小さなサイクル
  → Auto Grader + AI Grader のハイブリッド

品質ゲート（12_QUALITY_GATES.md）:
  → Phase間の品質判定（8ステージ）
  → SSOT監査、コード監査、テスト監査 etc.
  → 合格点を満たさないと次のPhaseに進めない

関係:
  検証ループ（小サイクル）を回しながら品質を積み上げ、
  品質ゲート（大サイクル）で最終判定する。

  実装中: /checkpoint → /verify → 修正 → ...（検証ループ）
  Phase完了時: framework audit → 合格判定 → 次のPhase（品質ゲート）
```

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|-------|
| | 初版作成 | |
