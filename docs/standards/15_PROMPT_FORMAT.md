# 15_PROMPT_FORMAT.md - 実装プロンプトフォーマット

> タスクごとにAIに渡す実装プロンプトの構成・品質基準

---

## 基本原則

```
プロンプト = AIへの作業指示書
SSOTが「何を作るか」なら、プロンプトは「どう作らせるか」

品質の連鎖:
  良いSSO → 良いプロンプト → 良い実装 → 良いプロダクト
  雑なSSOT → 雑なプロンプト → 手戻りの嵐

プロンプトを書いてからAIに投げる。
プロンプトを監査してからAIに投げる。
これが最も効率的な開発フローである。
```

---

## プロンプト構成（7セクション）

```
根拠:
  - Anthropic Prompt Engineering Guide
  - OpenAI Best Practices
  - Chain of Thought / Structured Output 手法
  - Few-shot / Role-based Prompting

全てのセクションに意味がある。省略すると品質が下がる。
```

### 全体構造

```
┌─ 実装プロンプト ──────────────────────────────────────┐
│                                                         │
│  §1. ロール定義                                        │
│  §2. コンテキスト（SSOT参照）                          │
│  §3. タスク指示                                        │
│  §4. 制約・規約                                        │
│  §5. 期待するアウトプット                              │
│  §6. 受け入れ基準                                      │
│  §7. 禁止事項                                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## §1. ロール定義

```
AIに専門家としての振る舞いを指定する。
ロールを明示することで、回答の品質と一貫性が向上する。

フォーマット:
──────────────────────────────────────
あなたは [技術スタック] に精通したシニアエンジニアです。
以下の原則に従って実装してください:
- [原則1]
- [原則2]
- [原則3]
──────────────────────────────────────

例（バックエンド実装の場合）:
──────────────────────────────────────
あなたは Next.js App Router + Supabase に精通した
シニアバックエンドエンジニアです。
以下の原則に従って実装してください:
- 型安全性を最優先する（TypeScript strict mode）
- エラーハンドリングを省略しない
- セキュリティを考慮した実装を行う
──────────────────────────────────────

レイヤー別のロール:
  DB:   データベースエンジニア + DBA
  API:  バックエンドエンジニア + セキュリティエンジニア
  UI:   フロントエンドエンジニア + UXエンジニア
  テスト: QAエンジニア + テスト自動化エンジニア
```

---

## §2. コンテキスト（SSOT参照）

```
AIに必要な情報を全て渡す。
「文脈がない指示」は「仕様がないコーディング」と同じ。

フォーマット:
──────────────────────────────────────
## コンテキスト

### 対象機能
- 機能ID: [FEAT-XXX]
- 機能名: [機能名]
- SSOT: [ファイルパスまたは内容]

### 参照セクション
[SSOTの該当セクションをそのまま貼り付け]

### 関連ドキュメント
- 技術スタック: [TECH_STACK.md の内容]
- コーディング規約: [CODING_STANDARDS.md の内容]
- 既存実装: [関連する既存コードのパスまたは内容]

### 依存する実装（完了済み）
- [先行タスクで作成済みのファイル・関数]
──────────────────────────────────────

注意:
  - SSOTの該当セクションは「要約」ではなく「原文」を貼る
  - AIに推測させない。必要な情報は全て明示する
  - 既存コードがある場合は必ず参照させる（二重実装を防ぐ）
```

---

## §3. タスク指示

```
何を実装するかを明確に指示する。
曖昧な指示は曖昧な実装を生む。

フォーマット:
──────────────────────────────────────
## タスク

### 実装内容
[やることを箇条書きで列挙]

### 実装の順序
1. [最初にやること]
2. [次にやること]
3. [最後にやること]

### ファイル構成
[作成・変更するファイルの一覧]
──────────────────────────────────────

例（API実装の場合）:
──────────────────────────────────────
## タスク

### 実装内容
- POST /api/v1/analysis エンドポイントを実装
- リクエストバリデーション（zod schema）
- 画像データの受け取りとSupabase Storageへの保存
- 外部AI API（OpenAI Vision）への分析リクエスト
- 分析結果のDB保存
- レスポンス返却

### 実装の順序
1. zod schema でリクエスト/レスポンス型を定義
2. Supabase Storage への画像保存関数を実装
3. OpenAI Vision API 呼び出し関数を実装
4. メインのRoute Handler を実装
5. エラーハンドリングを実装

### ファイル構成
作成:
  src/app/api/v1/analysis/route.ts    ← Route Handler
  src/lib/validators/analysis.ts      ← zod schema
  src/lib/services/storage.ts         ← 画像保存
  src/lib/services/vision.ts          ← AI分析
  src/types/analysis.ts               ← 型定義
変更:
  なし
──────────────────────────────────────
```

---

## §4. 制約・規約

```
従うべきルールを明示する。
これがないとAIは自己判断で実装し、規約違反のコードが生まれる。

フォーマット:
──────────────────────────────────────
## 制約

### 技術制約
- [使用するライブラリ/フレームワーク]
- [バージョン制約]
- [使ってはいけないライブラリ]

### コーディング規約
- [命名規約]
- [ファイル構成規約]
- [インポート規約]

### アーキテクチャ制約
- [レイヤー構成]
- [依存方向]
- [状態管理方式]

### パフォーマンス制約
- [応答時間の上限]
- [メモリ使用量の上限]
──────────────────────────────────────

例:
──────────────────────────────────────
## 制約

### 技術制約
- Next.js 14 App Router（Pages Router 不可）
- Supabase Client は @supabase/ssr を使用
- 画像処理に sharp は使わない（Vercel Edge 非対応）

### コーディング規約
- 関数名: camelCase
- ファイル名: kebab-case
- 型名: PascalCase
- エラーは Result 型パターン（throw しない）
- 1ファイル300行以内

### アーキテクチャ制約
- Route Handler → Service → Repository の3層
- Service 層に直接 Supabase Client を書かない
- 環境変数は env.ts から取得

### パフォーマンス制約
- API応答: 3秒以内（AI分析除く）
- AI分析: 10秒以内（タイムアウトを設定すること）
──────────────────────────────────────
```

---

## §5. 期待するアウトプット

```
AIの出力形式を明確に指定する。
指定しないとAIは説明文を延々と書き、コードが断片的になる。

フォーマット:
──────────────────────────────────────
## アウトプット

### 出力形式
[以下のいずれか、または組み合わせ]
- 完全なファイル内容（省略・コメントなし）
- ファイルごとに分割して出力
- 差分のみ（既存ファイルへの追加・変更）

### 必須要素
- [ ] 型定義
- [ ] エラーハンドリング
- [ ] バリデーション
- [ ] JSDocコメント（公開関数）
- [ ] [その他]

### 不要な要素
- 実装方針の説明は不要（コードのみ出力）
- テストは別タスクで実施するためここでは不要
- package.json の変更がある場合は変更点のみ列挙
──────────────────────────────────────

重要:
  「完全なファイル内容を出力してください。
   途中省略やコメントでの省略はしないでください。」
  この一文がないとAIは // ... 残りの実装 と省略する
```

---

## §6. 受け入れ基準

```
SSOTの §3 機能要件と §10 テストケースから抽出する。
AIに「これが満たされていなければ不完全」と伝える。

フォーマット:
──────────────────────────────────────
## 受け入れ基準

### 機能要件（SSOTの§3から）
- [ ] FR-001 [MUST]: [要件]
- [ ] FR-002 [MUST]: [要件]
- [ ] FR-003 [SHOULD]: [要件]

### 確認項目
- [ ] 全てのMUST要件が実装されている
- [ ] エラーハンドリングが全ケース実装されている
- [ ] 型安全である（any を使っていない）
- [ ] コーディング規約に違反していない
- [ ] 既存コードを破壊していない
──────────────────────────────────────
```

---

## §7. 禁止事項

```
AIがやりがちな問題を事前に防ぐ。
過去の経験から得られた「AIがよくやるミス」リスト。

フォーマット:
──────────────────────────────────────
## 禁止事項

以下は絶対にしないでください:
- any 型の使用
- console.log をプロダクションコードに残す
- 環境変数のハードコード
- try-catch で握りつぶし（空の catch ブロック）
- 実装の途中省略（// TODO や // ... は不可）
- 未使用の import
- SSOTに定義されていない独自仕様の追加
- テスト用のモックデータをプロダクションコードに混入
──────────────────────────────────────
```

---

## プロンプトテンプレート（完全版）

```markdown
# [FEAT-XXX-LAYER] [機能名] - [レイヤー]実装

## §1 ロール
あなたは [技術スタック] に精通したシニア[レイヤー]エンジニアです。
以下の原則に従って実装してください:
- [原則1]
- [原則2]
- [原則3]

## §2 コンテキスト

### 対象機能
- 機能ID: [FEAT-XXX]
- 機能名: [名前]

### SSOT参照セクション
```
[SSOTの該当セクションの原文を貼り付け]
```

### 技術スタック
```
[TECH_STACK.md の該当部分を貼り付け]
```

### コーディング規約
```
[CODING_STANDARDS.md の該当部分を貼り付け]
```

### 既存実装
```
[関連する既存コードのパスと内容]
```

### 依存する実装（完了済み）
- [先行タスクの成果物]

## §3 タスク

### 実装内容
- [やること1]
- [やること2]
- [やること3]

### 実装の順序
1. [順序1]
2. [順序2]
3. [順序3]

### ファイル構成
作成: [ファイル一覧]
変更: [ファイル一覧]

## §4 制約

### 技術制約
- [制約1]
- [制約2]

### コーディング規約
- [規約1]
- [規約2]

### アーキテクチャ制約
- [制約1]
- [制約2]

## §5 アウトプット

### 出力形式
完全なファイル内容を出力してください。
途中省略やコメントでの省略はしないでください。
ファイルごとに分割して出力してください。

### 必須要素
- [ ] 型定義
- [ ] エラーハンドリング
- [ ] バリデーション
- [ ] JSDocコメント（公開関数）

## §6 受け入れ基準

### 機能要件
- [ ] FR-001 [MUST]: [要件]
- [ ] FR-002 [MUST]: [要件]

### 確認項目
- [ ] 全MUST要件が実装されている
- [ ] エラーハンドリングが全ケース網羅
- [ ] 型安全（any 不使用）
- [ ] 規約準拠

## §7 禁止事項
- any 型の使用
- console.log のプロダクションコード残存
- 環境変数のハードコード
- try-catch の握りつぶし
- 実装の途中省略
- SSOTに定義されていない独自仕様の追加
```

---

## タスクサイズとプロンプト分割

### 分割基準

```
1プロンプト = AIが1回で精度高く実装できる量

目安:
  - 出力が500行以内 → 1プロンプト
  - 出力が500-1000行 → 2プロンプトに分割
  - 出力が1000行超 → 3プロンプト以上に分割

分割の原則:
  - ファイル単位で分割（1プロンプト = 1-3ファイル）
  - 依存順に分割（型定義 → ロジック → 統合）
  - 先に生成したコードを次のプロンプトのコンテキストに含める
```

### 大タスクの分割例

```
Task: FEAT-001-API（API実装）が大きい場合

  Sub-prompt 1: 型定義 + バリデーション
    → analysis.ts, validators/analysis.ts

  Sub-prompt 2: サービス層
    → services/storage.ts, services/vision.ts
    ※ Sub-prompt 1の出力をコンテキストに含める

  Sub-prompt 3: Route Handler + エラーハンドリング
    → api/v1/analysis/route.ts
    ※ Sub-prompt 1, 2の出力をコンテキストに含める
```

---

## レイヤー別プロンプトガイド

### DB実装プロンプト（特有の注意点）

```
§2 に含めるべき追加情報:
- 既存テーブル一覧（ERダイアグラム）
- インデックス戦略
- RLS（Row Level Security）ポリシー

§4 制約で強調すべき:
- マイグレーションは冪等であること
- ロールバック用の down マイグレーションも作成
- 既存データを壊さないこと
```

### API実装プロンプト（特有の注意点）

```
§2 に含めるべき追加情報:
- SSOTの §5 API仕様（エンドポイント定義の全文）
- SSOTの §7 ビジネスルール（全ルール）
- SSOTの §9 エラーハンドリング（全ケース）

§4 制約で強調すべき:
- 入力バリデーションは必須（zod等）
- 全エラーケースをハンドリング
- 認証チェックを忘れない
```

### UI実装プロンプト（特有の注意点）

```
§2 に含めるべき追加情報:
- SSOTの §6 UI仕様（レイアウト、状態遷移の全文）
- デザインシステム / コンポーネントライブラリのドキュメント
- 参考UIのスクリーンショット（あれば）

§4 制約で強調すべき:
- アクセシビリティ（WCAG 2.1 AA）
- レスポンシブ対応
- ローディング・エラー・空状態の全表示
```

### テスト実装プロンプト（特有の注意点）

```
§2 に含めるべき追加情報:
- SSOTの §10 テストケース（全ケースの全文）
- テスト対象のソースコード（実装済みのファイル全文）
- テスティングフレームワークの設定

§4 制約で強調すべき:
- SSOTのテストケースを1つも漏らさない
- テスト名は日本語で内容がわかるようにする
- モックは最小限に（実際のDBを使えるならテスト用DBを使う）
```

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|-------|
| | 初版作成 | |
