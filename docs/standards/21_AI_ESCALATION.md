# 21_AI_ESCALATION.md - AI 中断・質問プロトコル

> AIが独断で進めず、疑問点を即座にユーザーに確認する体制

---

## 基本原則

```
AIは「わからないこと」を推測して進めてはならない。

推測で進めた場合のコスト:
  AIが勝手に決定 → 実装完了 → レビューで発覚 → 手戻り
  = 数時間〜数日のロス

即座に質問した場合のコスト:
  AIが中断 → 質問 → 回答（1分）→ SSOT更新 → 正確な実装
  = 1分のロス

結論: 1%でも不明な点があれば、即座に中断して質問する
```

---

## 中断トリガー（AIが中断すべき状況）

### 7つの中断トリガー

```
以下のいずれかに該当したら、AIは即座に作業を中断し、
ユーザーに質問する。

T1: SSOT に記載がない仕様判断
────────────────────────────────
  「この場合どう動くべきか」がSSOTに書かれていない。

  例: 「同時に2つのファイルをアップロードした場合の動作」
      がSSOTに定義されていない。
  → 中断して質問

T2: SSOT の記載が曖昧
────────────────────────────────
  SSOTに記載はあるが、複数の解釈が可能。

  例: 「適切なエラーメッセージを表示する」
      → 何が「適切」かが不明
  → 中断して質問

T3: 技術的な選択肢が複数ある
────────────────────────────────
  実装方法が複数あり、どれを選ぶべきか判断できない。

  例: リアルタイム更新を
      a) WebSocket で実装
      b) Server-Sent Events で実装
      c) ポーリングで実装
      → どれがこのプロジェクトに適切か不明
  → 中断して質問

T4: SSOTと既存実装の矛盾
────────────────────────────────
  SSOTの定義と、既存のコードが矛盾している。

  例: SSOTでは「論理削除」と定義されているが、
      既存の別機能では「物理削除」で実装されている。
  → 中断して質問（SSOTが正か、既存実装が正か）

T5: 制約・規約に未定義のケース
────────────────────────────────
  コーディング規約やアーキテクチャ制約に記載のない
  パターンに遭遇した。

  例: 規約では「Service層からRepositoryを呼ぶ」だが、
      今回は外部APIも呼ぶ必要がある。
      Service → ExternalAPI の位置づけが未定義。
  → 中断して質問

T6: 影響範囲が不明
────────────────────────────────
  この変更が他の機能にどう影響するか判断できない。

  例: DBスキーマを変更したいが、
      他の機能がこのテーブルを参照しているか不明。
  → 中断して質問

T7: ビジネス判断が必要
────────────────────────────────
  技術的にはどちらでも実装できるが、
  ビジネス要件としてどうすべきかわからない。

  例: 無料プランの制限を超えた場合、
      a) 機能をブロックする
      b) 警告を出して続行を許可する
      → ビジネス判断
  → 中断して質問
```

---

## 中断時の行動プロトコル

### ステップ1: 即座に中断

```
AIは以下のフォーマットで中断を通知する:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 作業を中断します（確認が必要です）

トリガー: [T1〜T7のどれか]
発生箇所: [何をしている時に発生したか]

質問:
[具体的な質問]

選択肢（あれば）:
a) [選択肢A] → [その場合の影響]
b) [選択肢B] → [その場合の影響]
c) [選択肢C] → [その場合の影響]

推奨: [AIの推奨があれば]
推奨の根拠: [なぜその推奨か]

影響範囲:
[この決定が影響する他の機能・ドキュメント]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### ステップ2: ユーザーの回答を待つ

```
AIはユーザーの回答が得られるまで:
- 該当タスクの作業を停止する
- 推測で進めない
- 「とりあえず仮で進める」をしない
- 影響を受けない別のタスクがあれば、そちらを先に進めてよい
```

### ステップ3: 回答に基づくSSO/プロンプト更新

```
ユーザーの回答を得たら:

1. 回答をSSOTの該当セクションに反映
   → 「§7 ビジネスルール BR-012 を追加」等

2. 更新したSSOTのセクションをユーザーに確認
   「SSOTを以下のように更新しました:
    [更新内容]
    この内容で正しいですか？」

3. ユーザーの確認を得てから作業を再開

4. プロンプトにも反映が必要な場合はプロンプトも更新
```

---

## 各フェーズでの中断ルール

### プロンプト作成時

```
プロンプトを書いている時に中断すべきケース:

- SSOTの参照セクションに曖昧な記述がある
  → T2: 中断して明確化を求める
  → 明確化した内容でSSOTを更新してからプロンプトに反映

- 実装順序が不明
  → T3: 中断して確認
  → 例:「バリデーションをフロント側かサーバー側か、
        どちらで先に実装しますか？」

- SSOTにない要件を書こうとしている
  → T1: 中断して確認
  → 例:「プロンプトに書くべきエッジケースが
        SSOTに定義されていません。追加しますか？」
```

### 実装時

```
コードを書いている時に中断すべきケース:

- SSOTのビジネスルールが特定のケースをカバーしていない
  → T1: 中断して質問
  → 例:「入力が空文字の場合の動作がSSOTに
        定義されていません。どうしますか？」

- 技術的に複数のアプローチがある
  → T3: 中断して質問
  → 例:「この処理、同期と非同期どちらで実装しますか？
        a) 同期: シンプルだがUIが3秒ブロックされる
        b) 非同期: UIは即応答だが実装が複雑」

- 既存コードとの矛盾を発見
  → T4: 中断して質問
  → 例:「SSOTでは日時をUTCで保存と定義されていますが、
        既存のusersテーブルではJSTで保存されています。
        どちらに統一しますか？」
```

### 修正時

```
コードを修正している時に中断すべきケース:

- 修正の影響範囲が判断できない
  → T6: 中断して質問
  → 例:「この修正でAPIのレスポンス型が変わります。
        フロントの[画面名]にも影響しますが、
        そちらも同時に修正しますか？」

- 修正がSSOTの変更を必要とする
  → T4: 中断して質問
  → 例:「バグ修正のためにSSOTの§7 BR-005を
        変更する必要があります。承認しますか？
        変更内容: [具体的な変更]」
```

### テスト時

```
テストを書いている/実行している時に中断すべきケース:

- SSOTのテストケースでカバーされていないケースを発見
  → T1: 中断して質問
  → 例:「テスト中に、SSOTに定義されていないエッジケースを
        発見しました。[具体的なケース]
        テストを追加しSSOTにも反映しますか？」

- テストが失敗し、SSOTとコードのどちらが正しいか不明
  → T4: 中断して質問
  → 例:「テストが失敗しています。
        SSOTの定義: [定義内容]
        実際の動作: [実際の動作]
        SSOTが正しいですか？それとも実装が正しいですか？」
```

---

## SSOT更新フロー

```
質問発生
    │
    ▼
ユーザー回答
    │
    ▼
回答がSSOTの変更を必要とするか？
    │
    ├── No → 回答を実装に直接反映 → 作業再開
    │
    └── Yes
        │
        ▼
    SSOT更新案を作成
        │
        ▼
    ユーザーに更新内容を確認
    「SSOTの§X を以下のように更新します:
     [変更前] → [変更後]
     よろしいですか？」
        │
        ├── OK → SSOT更新 → 作業再開
        └── 修正 → 修正案を再提示 → 確認
```

### SSOT更新記録

```
SSOTを更新した場合、§1 変更履歴に記録する:

| バージョン | 日付 | 変更内容 | 理由 | 変更者 |
|-----------|------|---------|------|-------|
| 1.1 | YYYY-MM-DD | §7 BR-012 追加: 空文字入力時のエラー | 実装時にT1トリガーで発覚 | AI + ユーザー |
```

---

## 止まらないルール（Progress-First Protocol）

### 基本原則

```
従来: 「仕様がないなら止まれ」（全停止）
改善: 「止まらず進む」ただし記録する

なぜ変更するか:
  - 全停止 → ユーザー待ち → 長時間ブロック → 開発停滞
  - 特にDETAIL層の未決定で全体が止まるのは非効率

新ルール:
  - 未決定項目はデフォルト案で実装してよい
  - ただし Decision Backlog に必ず記録する
  - 影響が大きい未決定は Feature Flag で隠してマージ可能にする
  - UI文言などは後回し、機能が動くこと優先
```

### 止まるべき場合 vs 進んでよい場合

```
■ 止まるべき場合（従来通り中断 T1-T7）:
────────────────────────────────────────

CORE層に関する不明点:
  - 機能の目的・スコープが不明 → T1: 中断
  - ビジネスルールの根幹が不明 → T7: 中断
  - 権限モデルが未定義 → T1: 中断

CONTRACT層に関する不明点:
  - APIの入出力型が確定していない → T1: 中断
  - DBの主要テーブル構造が不明 → T1: 中断
  - 画面遷移の根幹が不明 → T3: 中断

既存実装との矛盾:
  - SSOTと既存コードが矛盾 → T4: 中断（常に止まる）

影響範囲が不明:
  - 変更が他機能に波及する可能性 → T6: 中断（常に止まる）


■ 進んでよい場合（Decision Backlog に記録して続行）:
────────────────────────────────────────

DETAIL層に関する不明点:
  ✅ エラーメッセージの文言 → デフォルト文言で実装
  ✅ バリデーションの閾値 → 合理的なデフォルトで実装
  ✅ UI文言・ラベル → 仮文言で実装
  ✅ 性能目標の具体値 → 一般的な目標値で実装
  ✅ 例外ケースの詳細動作 → 安全側に倒して実装

技術的な選択肢が複数（T3の一部）:
  ✅ 性能に大差がない場合 → シンプルな方を選択
  ✅ 後から変更可能な場合 → デフォルトで実装 + Decision Backlog

ビジネス判断（T7の一部）:
  ✅ UI上の表示順・並び順 → デフォルト（新しい順）で実装
  ✅ 無料/有料の境界 → Feature Flag で切り替え可能に実装
```

### 進む場合の行動プロトコル

```
Step 1: デフォルト案を選定
────────────────────────────────
  - 安全側に倒す（セキュリティ > 利便性）
  - シンプルな方を選ぶ
  - 後から変更しやすい方を選ぶ

Step 2: Decision Backlog に記録
────────────────────────────────
  docs/ssot/DECISION_BACKLOG.md に以下を追記:
  - 何が未決定か
  - なぜデフォルト案を選んだか
  - 他の選択肢と副作用
  - いつまでに決定が必要か

Step 3: コードにマーカーを付与
────────────────────────────────
  // DECISION: DB-001 - デフォルト案Aで実装。決定後に変更の可能性あり
  const MAX_RETRY = 3; // DB-001: 要確認

Step 4: 影響が大きい場合は Feature Flag
────────────────────────────────
  if (featureFlags.isEnabled('DB-001-optionA')) {
    // 案A の実装
  } else {
    // 案B の実装（またはデフォルト）
  }

Step 5: ユーザーへの報告（セッション終了時）
────────────────────────────────
  「以下の未決定項目をデフォルト案で実装しました:

   DB-001: エラーリトライ回数 → デフォルト: 3回
   DB-002: セッション有効期限 → デフォルト: 24時間
   DB-003: 画像サイズ上限 → デフォルト: 10MB

   Decision Backlog に記録済みです。
   確認・決定をお願いします。」
```

### T1-T7 との整合性マトリクス

```
| トリガー | 従来 | 新ルール | 条件 |
|---------|------|---------|------|
| T1: SSOT未記載 | 全停止 | 層による | CORE/CONTRACT→停止、DETAIL→進む |
| T2: SSOT曖昧 | 全停止 | 層による | CORE/CONTRACT→停止、DETAIL→進む |
| T3: 技術選択肢複数 | 全停止 | 条件付き進行 | 後から変更可能なら進む |
| T4: SSOTと実装矛盾 | 全停止 | 全停止（変更なし） | 常に止まる |
| T5: 規約未定義 | 全停止 | 条件付き進行 | 安全側のデフォルトで進む |
| T6: 影響範囲不明 | 全停止 | 全停止（変更なし） | 常に止まる |
| T7: ビジネス判断 | 全停止 | 条件付き進行 | Feature Flag で切替可能なら進む |

判定フロー:
  不明点を発見
    │
    ├── CORE層 or CONTRACT層か？ → Yes → 従来通り停止（T1-T7）
    │
    ├── T4 or T6 か？ → Yes → 常に停止
    │
    ├── DETAIL層か？ → Yes → デフォルト案で進む
    │   │                     + Decision Backlog に記録
    │   │
    │   └── 影響が大きいか？ → Yes → Feature Flag で隠す
    │                         → No → そのまま実装
    │
    └── 判断できない → 停止して質問
```

### CLAUDE.md への組み込み

```markdown
## 止まらないルール

DETAIL層の未決定はデフォルト案で実装し、Decision Backlog に記録すること。
CORE層・CONTRACT層の未決定は従来通り停止して質問すること。
T4（矛盾）とT6（影響範囲不明）は常に停止すること。
詳細: docs/standards/21_AI_ESCALATION.md「止まらないルール」セクション
```

---

## Claude Code への組み込み

### CLAUDE.md に追加するルール

```markdown
## AI中断プロトコル（必須）

以下の場合、即座に作業を中断しユーザーに質問してください:

1. SSOTに記載がない仕様判断が必要な時
2. SSOTの記載が曖昧で複数解釈が可能な時
3. 技術的な選択肢が複数あり判断できない時
4. SSOTと既存実装が矛盾している時
5. 制約・規約に未定義のケースに遭遇した時
6. 変更の影響範囲が判断できない時
7. ビジネス判断が必要な時

中断時のフォーマット:
⚠️ 確認が必要です
トリガー: [T1-T7]
質問: [具体的な質問]
選択肢: [あれば]
推奨: [あれば]

「推測で進める」「とりあえず仮で」は禁止です。
1%でも不明な点があれば質問してください。
```

### .cursorrules に追加するルール

```
# AI中断プロトコル
不明点がある場合は作業を中断し、ユーザーに質問すること。
推測で実装を進めることは禁止。
docs/21_AI_ESCALATION.md の7つのトリガーに該当する場合は
必ず中断して質問する。
```

---

## 禁止行動リスト

```
以下の行動は明確に禁止する:

❌ 「おそらく○○だろう」と推測して実装する
❌ 「一般的には○○なので」と勝手にデフォルトを選ぶ
❌ 「後で確認する」として仮実装で進める
❌ TODO/FIXMEコメントで不明点を後回しにする
❌ SSOTにない仕様を「良かれと思って」追加する
❌ エラーケースが不明だから握りつぶす
❌ 「些細なことだから」と判断して質問しない
❌ 複数回の質問を避けるために曖昧なまま進める
```

---

## 質問の品質基準

```
良い質問:
  「入力が空文字の場合、SSOTに定義がありません。
   a) バリデーションエラーにする（推奨: 一般的なパターン）
   b) 空文字を許可する
   どちらにしますか？」

悪い質問:
  「入力チェックどうしますか？」
  → 何が聞きたいのか不明。選択肢も推奨もない。

質問のチェックリスト:
  □ 何について聞いているか明確
  □ なぜ聞く必要があるか（トリガー）が明示
  □ 選択肢がある（可能な場合）
  □ 推奨がある（根拠付き）
  □ この決定の影響範囲が明示
```

---

## 自己進化型CLAUDE.md（再帰的学習）

### 基本原則

```
同じミスを二度としない。

ミス発生時の対応:
  従来: コードを修正して終了
  改善: コード修正 ＋ CLAUDE.md にルールを追記

  ミス発生
    │
    ├── ① コードを修正する（従来通り）
    │
    └── ② CLAUDE.md に再発防止ルールを追記する（NEW）
        │
        ├── 何が起きたか（1文）
        ├── なぜ起きたか（根本原因）
        └── 今後のルール（具体的な禁止/必須事項）
```

### ルール追記のトリガー

```
以下の場合、CLAUDE.md の ## 学習済みルール セクションに追記する:

R1: 同じ種類のバグを2回以上修正した
────────────────────────────────
  例: any型が原因のバグを2回修正
  → 追記: 「any型は絶対に使用しない。unknown + 型ガードを使う」

R2: SSOT監査 / コード監査で同じ減点が2回発生した
────────────────────────────────
  例: console.log残存で2回減点
  → 追記: 「実装完了時に console.log を全削除する」

R3: レビューで同じ指摘を受けた
────────────────────────────────
  例: エラーハンドリング漏れを2回指摘
  → 追記: 「API呼び出しには必ず try-catch + エラー表示を実装する」

R4: テスト失敗の原因パターンが繰り返された
────────────────────────────────
  例: 非同期処理のawait忘れでテスト失敗が2回
  → 追記: 「非同期関数呼び出しは await を必ず付ける」

R5: 中断質問の回答が汎用ルールとして適用可能
────────────────────────────────
  例: 「日時はすべてUTCで保存する」という回答
  → 追記: 「日時データは常にUTCで保存する」
```

### CLAUDE.md への追記フォーマット

```markdown
## 学習済みルール（自動追記）

このセクションはAIが開発中に学んだルールを自動追記する。
新しいルールは末尾に追加する。

### [YYYY-MM-DD] [カテゴリ]
- ルール: [具体的なルール]
- 根拠: [なぜこのルールが必要か]
- 発生元: [どのタスク/監査で判明したか]
```

### 追記時の行動プロトコル

```
1. ルールの追記案を作成
2. ユーザーに提示して確認を求める
   「以下のルールをCLAUDE.mdに追記してもいいですか？
    ルール: [内容]
    理由: [2回同じミスが発生したため]」
3. 承認を得てからCLAUDE.mdに追記
4. 追記後、既存コードに同じ問題がないかスキャンする
```

### 禁止事項

```
❌ ユーザーの確認なしにCLAUDE.mdを変更する
❌ 1回限りの特殊ケースをルール化する（2回以上の再発が条件）
❌ プロジェクト固有すぎるルールを追記する（汎用性のあるものだけ）
❌ 既存のルールと矛盾するルールを追記する
```

---

## Memory Persistence（セッション間コンテキスト保存）

### 基本原則

```
Claude Code のセッションは揮発的（終了すると忘れる）。
重要なコンテキストを永続化し、次回セッション開始時に復元する。

保存先: .claude/memory/
読み込み: セッション開始時に CLAUDE.md から自動参照
```

### 保存対象

```
以下の4カテゴリを保存する:

1. 進行中のタスク状態
────────────────────────────────
  - 現在のPhase / Step
  - 完了済みタスク / 未完了タスク
  - ブロッカー（未解決の問題）

2. 重要な意思決定
────────────────────────────────
  - ユーザーが下した仕様判断
  - 技術選択の理由
  - 却下された選択肢とその理由

3. 学習したパターン
────────────────────────────────
  - プロジェクト固有のコーディングパターン
  - よく使うコマンド / ワークフロー
  - ユーザーの好み・スタイル

4. 未解決の問題
────────────────────────────────
  - 中断トリガーで保留中の質問
  - TODO / 技術的負債
  - 後で対応が必要な項目
```

### ファイル構造

```
.claude/memory/
├── session_state.json        ← タスク状態（JSON）
├── decisions.md              ← 意思決定ログ（Markdown）
├── patterns.json             ← 学習パターン（JSON）
└── open_issues.md            ← 未解決の問題（Markdown）
```

### session_state.json のフォーマット

```json
{
  "last_updated": "2025-01-15T10:30:00Z",
  "session_id": "abc123",
  "phase": "Phase 1",
  "step": "Step 4",
  "current_task": {
    "id": "AUTH-001",
    "name": "ログイン機能実装",
    "status": "in_progress",
    "subtasks": [
      { "name": "API実装", "status": "completed" },
      { "name": "UI実装", "status": "in_progress" },
      { "name": "テスト", "status": "pending" }
    ]
  },
  "completed_tasks": ["ACCT-001", "ACCT-002"],
  "blockers": [
    {
      "trigger": "T3",
      "question": "リアルタイム通知の実装方式",
      "status": "waiting_for_answer"
    }
  ]
}
```

### decisions.md のフォーマット

```markdown
# 意思決定ログ

## [2025-01-15] 認証方式の選定
- 決定: JWT + Refresh Token
- 理由: SPAでの運用性、セッション管理の柔軟性
- 却下案: Session Cookie（SSR前提のため不適）
- 影響: SSOT-5 §2, AUTH-001, AUTH-005

## [2025-01-14] DB選定
- 決定: Supabase (PostgreSQL)
- 理由: BaaS統合、リアルタイム機能、RLS
- 却下案: PlanetScale（MySQL制約）, Firebase（NoSQL制約）
- 影響: SSOT-4, 全機能
```

### セッション開始時の読み込みプロトコル

```
セッション開始時:

1. .claude/memory/ の存在を確認
   ├── 存在する → 前回の状態を読み込み
   └── 存在しない → 初回セッション（スキップ）

2. session_state.json を読み込み
   → 「前回の作業: {current_task.name} が {status} でした」
   → 「ブロッカー: {blockers} が未解決です」

3. decisions.md から直近5件を読み込み
   → 重要な意思決定を把握

4. open_issues.md を確認
   → 未解決の問題があればユーザーに報告

5. ユーザーに状態サマリーを表示
   「前回のセッションから継続します:
    現在: {phase} / {step}
    作業中: {current_task}
    未解決: {blockers の数}件

    続きから始めますか？それとも別のタスクに取り掛かりますか？」
```

### セッション終了時の保存プロトコル

```
セッション終了時（ユーザーが明示的に終了する場合）:

1. 現在のタスク状態を session_state.json に書き出し
2. セッション中の意思決定を decisions.md に追記
3. 新たに発見したパターンを patterns.json に追記
4. 未解決の問題を open_issues.md に追記
5. 保存完了を通知

「セッション状態を保存しました:
 .claude/memory/session_state.json  ← タスク状態
 .claude/memory/decisions.md        ← 意思決定 +{N}件
 .claude/memory/open_issues.md      ← 未解決 {N}件」
```

### CLAUDE.md への組み込み

```markdown
## Memory Persistence

セッション開始時に .claude/memory/ を読み込み、前回の状態を復元すること。
セッション終了時に現在の状態を .claude/memory/ に保存すること。
詳細: docs/standards/21_AI_ESCALATION.md「Memory Persistence」セクション
```

---

## Continuous Learning v2（Instinct-based Learning）

### 基本原則

```
v1: ルールベース（同じミスを2回繰り返したらルール化）
v2: 直感ベース（パターンを確信度で蓄積し、閾値超えでスキル化）

v1（自己進化型CLAUDE.md）: 明示的なミスの再発防止
v2（Instinct-based Learning）: 暗黙的なパターンの自動抽出と蓄積

両方を併用する。
```

### Instinct（直感）の定義

```
Instinct = {
  id: "INST-001",
  trigger: "どの場面で発動するか",
  action: "何をするか",
  confidence: 0-100,
  source: "何から学習したか",
  created: "YYYY-MM-DD",
  last_used: "YYYY-MM-DD",
  use_count: N
}

例:
{
  id: "INST-001",
  trigger: "APIエンドポイントを新規作成するとき",
  action: "必ず rate limiting middleware を適用する",
  confidence: 85,
  source: "AUTH-001, ACCT-001 の実装で2回とも必要だった",
  created: "2025-01-10",
  last_used: "2025-01-15",
  use_count: 3
}
```

### 確信度（Confidence）の計算

```
初期値: 30（初回の観察）

加算:
  +20: 同じパターンを再度観察
  +15: ユーザーがパターンを肯定
  +10: パターンが正しく動作した
  +5:  類似パターンを観察

減算:
  -20: パターンが誤りだった
  -15: ユーザーがパターンを否定
  -10: 例外ケースが見つかった

閾値:
  0-29:   記録のみ（使用しない）
  30-59:  低確信（参考情報として保持）
  60-79:  中確信（提案として表示）
  80-100: 高確信（スキル化を提案）
```

### 保存フォーマット

```
保存先: .claude/memory/instincts.json

{
  "instincts": [
    {
      "id": "INST-001",
      "trigger": "APIエンドポイントを新規作成するとき",
      "action": "rate limiting middleware を適用する",
      "confidence": 85,
      "source": "AUTH-001, ACCT-001 の実装パターン",
      "created": "2025-01-10",
      "last_used": "2025-01-15",
      "use_count": 3,
      "history": [
        { "date": "2025-01-10", "event": "初回観察", "delta": 30 },
        { "date": "2025-01-12", "event": "再度観察", "delta": 20 },
        { "date": "2025-01-14", "event": "ユーザー肯定", "delta": 15 },
        { "date": "2025-01-15", "event": "正常動作", "delta": 10 }
      ]
    }
  ],
  "meta": {
    "total": 12,
    "high_confidence": 3,
    "medium_confidence": 5,
    "low_confidence": 4
  }
}
```

### パターン抽出のトリガー

```
以下の場面で自動的にパターンを抽出する:

P1: 同じ構造のコードを2回以上書いた
────────────────────────────────
  例: try-catch + toast通知のパターンを3回書いた
  → Instinct: 「API呼び出しには try-catch + toast通知を実装する」
  → confidence: 30 + 20 + 20 = 70

P2: ユーザーの指示に繰り返しパターンがある
────────────────────────────────
  例: 「テストも書いて」を毎回指示される
  → Instinct: 「機能実装後にテストも自動生成する」
  → confidence: 30 + 20 = 50

P3: コード監査で同じ改善が繰り返される
────────────────────────────────
  例: Adversarial Review で毎回「型安全性」を指摘される
  → Instinct: 「実装時に型安全性を最優先で確認する」
  → confidence: 30 + 20 = 50

P4: 成功パターンの再利用
────────────────────────────────
  例: ある設計パターンが3つの機能で成功
  → Instinct: 「類似機能にはこの設計パターンを適用する」
  → confidence: 30 + 10 + 10 = 50
```

### スキル化の提案

```
confidence が 80 以上に達したら:

1. ユーザーにスキル化を提案
   「以下のパターンをスキルとして定着させませんか？

    パターン: {action}
    確信度: {confidence}/100
    根拠: {use_count}回の実績、{source}

    スキル化すると:
    - CLAUDE.md の学習済みルールに追加
    - 以降のセッションで自動適用」

2. ユーザーが承認 → CLAUDE.md に追記
3. ユーザーが否認 → confidence を -20 して保持
```

### v1（ルールベース）との併用

```
v1: 自己進化型CLAUDE.md
  → 明示的なミスの再発防止
  → トリガー: 同じミスが2回発生
  → 即座にルール化

v2: Instinct-based Learning
  → 暗黙的な成功パターンの蓄積
  → トリガー: パターンの繰り返し観察
  → 確信度が閾値を超えたらスキル化

併用フロー:
  ミス発生 → v1 でルール化（即座）
  成功パターン → v2 で Instinct 蓄積（段階的）
  Instinct が 80+ → v1 の学習済みルールに昇格
```

---

## Strategic Compact（戦略的コンパクション）

### 基本原則

```
Claude Code のコンテキストウィンドウは有限。
トークンを効率的に使い、最も重要な情報を常に保持する。

問題:
  セッションが長くなる → コンテキストが溢れる
  → 初期の重要な指示が押し出される
  → 品質が低下する

解決:
  戦略的にコンパクション（圧縮）を行い、
  重要度の高い情報を優先的に保持する。
```

### 情報の優先順位

```
Priority 1（絶対保持）:
────────────────────────────────
  - CLAUDE.md のルール
  - 現在のタスクのSSOT（全文）
  - 認証状態（S0-S4）
  - エラーコード体系
  - 中断トリガー（T1-T7）

Priority 2（要約して保持）:
────────────────────────────────
  - 関連するSSOTの要約
  - 直近の意思決定（5件）
  - 現在のファイルの全体構造
  - テスト結果のサマリー

Priority 3（参照時に読み込み）:
────────────────────────────────
  - 他の機能のSSOT
  - 過去の意思決定ログ
  - ディスカバリーの記録
  - 完了済みタスクの詳細

Priority 4（破棄可能）:
────────────────────────────────
  - 中間ステップの出力
  - 試行錯誤の履歴
  - 修正前のコード
  - デバッグ出力
```

### コンパクションタイミングの提案

```
AIは以下の場面でコンパクションを提案する:

CT1: 長いデバッグセッションの後
────────────────────────────────
  「デバッグが完了しました。コンテキストを整理しますか？
   保持: 修正結果 + 根本原因
   破棄: 中間の試行錯誤」

CT2: 大きなファイルの読み込み後
────────────────────────────────
  「ファイルの分析が完了しました。要約に切り替えますか？
   保持: 構造サマリー + 重要な関数シグネチャ
   破棄: ファイル全文」

CT3: タスク切り替え時
────────────────────────────────
  「タスク {A} が完了しました。次のタスク {B} に移る前に
   コンテキストを整理しますか？
   保持: {A} の結果サマリー
   破棄: {A} の実装詳細」

CT4: セッションが長時間経過
────────────────────────────────
  「セッションが長くなっています。
   現在のコンテキスト使用量: 約 {N}%
   コンパクションを推奨します。」
```

### コンパクション実行手順

```
ユーザーの承認後:

1. Priority 4 の情報を破棄
2. Priority 3 の情報を .claude/memory/ に退避
3. Priority 2 の情報を要約に変換
4. Priority 1 の情報はそのまま保持

結果を報告:
  「コンテキストを整理しました:
   保持: {Priority 1 の項目リスト}
   要約: {Priority 2 の項目リスト}
   退避: {Priority 3 の項目リスト}（.claude/memory/ に保存）
   破棄: {Priority 4 の項目数}件」
```

### /compact コマンド

```
ユーザーが手動でコンパクションを実行するコマンド:

/compact
  → 現在のコンテキスト状態を分析
  → 優先順位に基づいて整理案を提示
  → ユーザーの承認後に実行

/compact --auto
  → Priority 4 を自動破棄
  → Priority 3 を自動退避
  → 報告のみ（承認不要）

/compact --status
  → 現在のコンテキスト使用状況を表示
  → 「Priority 1: {N}項目, Priority 2: {N}項目, ...」
```

### CLAUDE.md への組み込み

```markdown
## Strategic Compact

コンテキストが逼迫したら戦略的コンパクションを提案すること。
Priority 1 の情報は絶対に破棄しない。
詳細: docs/standards/21_AI_ESCALATION.md「Strategic Compact」セクション
```

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|-------|
| | 初版作成 | |
| | 自己進化型CLAUDE.md（再帰的学習）セクション追加 | |
| | Memory Persistence、Continuous Learning v2、Strategic Compact を追加 | |
| | 止まらないルール（Progress-First Protocol）を追加。T1-T7との整合性マトリクス定義 | |
